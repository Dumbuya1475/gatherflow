
-- Enums
create type public.ticket_status as enum ('pending', 'approved', 'rejected', 'checked_in', 'checked_out', 'expired', 'cancelled');
create type public.field_type as enum ('text', 'number', 'date', 'boolean', 'multiple-choice', 'checkboxes', 'dropdown');
create type public.fee_bearer_type as enum ('organizer', 'buyer');

-- Profiles Table
create table public.profiles (
  id uuid not null references auth.users on delete cascade,
  first_name text,
  last_name text,
  avatar_url text,
  is_guest boolean default false not null,
  phone text,
  email text,
  primary key (id)
);
alter table public.profiles enable row level security;
create policy "Public profiles are viewable by everyone." on public.profiles for select using (true);
create policy "Users can insert their own profile." on public.profiles for insert with check (auth.uid() = id);
create policy "Users can update own profile." on public.profiles for update using (auth.uid() = id);

-- Events Table
create table public.events (
  id bigint generated by default as identity primary key,
  created_at timestamp with time zone default now() not null,
  title text not null,
  description text,
  welcome_message text,
  date timestamp with time zone not null,
  end_date timestamp with time zone,
  location text,
  cover_image text,
  ticket_brand_logo text,
  ticket_brand_color text,
  ticket_background_image text,
  organizer_id uuid references public.profiles,
  capacity integer,
  is_paid boolean default false not null,
  price double precision,
  fee_bearer public.fee_bearer_type default 'buyer'::public.fee_bearer_type not null,
  is_public boolean default true not null,
  requires_approval boolean default false not null,
  status text default 'draft'::text,
  payout_completed boolean default false not null
);
alter table public.events enable row level security;
create policy "Events are viewable by everyone." on public.events for select using (true);
create policy "Organizers can create events." on public.events for insert with check (auth.uid() = organizer_id);
create policy "Organizers can update their own events." on public.events for update using (auth.uid() = organizer_id);
create policy "Organizers can delete their own events." on public.events for delete using (auth.uid() = organizer_id);


-- Tickets Table
create table public.tickets (
  id bigint generated by default as identity primary key,
  created_at timestamp with time zone default now() not null,
  event_id bigint references public.events on delete cascade,
  user_id uuid references public.profiles on delete cascade,
  qr_token text unique,
  checked_in boolean default false not null,
  checked_in_at timestamp with time zone,
  checked_out boolean default false not null,
  checked_out_at timestamp with time zone,
  status public.ticket_status default 'pending'::public.ticket_status not null,
  monime_checkout_session_id text,
  monime_payment_status text,
  ticket_price double precision,
  platform_fee double precision,
  payment_processor_fee double precision,
  organizer_amount double precision
);
alter table public.tickets enable row level security;
create policy "Tickets are viewable by owner or event organizer." on public.tickets for select using (auth.uid() = user_id or exists (select 1 from public.events where events.id = tickets.event_id and events.organizer_id = auth.uid()));
create policy "Users can create tickets for themselves." on public.tickets for insert with check (auth.uid() = user_id);
create policy "Organizers can update tickets for their events." on public.tickets for update using (exists (select 1 from public.events where events.id = tickets.event_id and events.organizer_id = auth.uid()));

-- Event Scanners Table
create table public.event_scanners (
    id bigint generated by default as identity primary key,
    event_id bigint not null references public.events on delete cascade,
    user_id uuid not null references public.profiles on delete cascade,
    created_at timestamp with time zone default now() not null,
    unique (event_id, user_id)
);
alter table public.event_scanners enable row level security;
create policy "Scanners are viewable by event organizer." on public.event_scanners for select using (exists (select 1 from public.events where events.id = event_scanners.event_id and events.organizer_id = auth.uid()));
create policy "Organizers can add/remove scanners." on public.event_scanners for all using (exists (select 1 from public.events where events.id = event_scanners.event_id and events.organizer_id = auth.uid()));

-- Event Form Fields Table
create table public.event_form_fields (
    id bigint generated by default as identity primary key,
    event_id bigint not null references public.events on delete cascade,
    field_name text not null,
    field_type public.field_type not null,
    is_required boolean default false not null,
    "order" integer not null
);
alter table public.event_form_fields enable row level security;
create policy "Form fields are public." on public.event_form_fields for select using (true);
create policy "Organizers can manage form fields for their events." on public.event_form_fields for all using (exists (select 1 from public.events where events.id = event_form_fields.event_id and events.organizer_id = auth.uid()));

-- Event Form Field Options Table
create table public.event_form_field_options (
    id bigint generated by default as identity primary key,
    form_field_id bigint not null references public.event_form_fields on delete cascade,
    value text not null
);
alter table public.event_form_field_options enable row level security;
create policy "Field options are public." on public.event_form_field_options for select using (true);
create policy "Organizers can manage field options." on public.event_form_field_options for all using (exists (select 1 from public.event_form_fields ff join public.events e on ff.event_id = e.id where ff.id = event_form_field_options.form_field_id and e.organizer_id = auth.uid()));


-- Attendee Form Responses Table
create table public.attendee_form_responses (
    id bigint generated by default as identity primary key,
    ticket_id bigint not null references public.tickets on delete cascade,
    form_field_id bigint not null references public.event_form_fields on delete cascade,
    field_value text not null
);
alter table public.attendee_form_responses enable row level security;
create policy "Responses are viewable by ticket owner or event organizer." on public.attendee_form_responses for select using (exists (select 1 from public.tickets t where t.id = attendee_form_responses.ticket_id and (t.user_id = auth.uid() or exists (select 1 from public.events e where e.id = t.event_id and e.organizer_id = auth.uid()))));
create policy "Attendees can create responses for their own tickets." on public.attendee_form_responses for insert with check (exists (select 1 from public.tickets t where t.id = attendee_form_responses.ticket_id and t.user_id = auth.uid()));

-- Payouts Table
create table public.payouts (
    id bigint generated by default as identity primary key,
    event_id bigint not null references public.events,
    organizer_id uuid not null references public.profiles,
    total_tickets_sold integer,
    gross_amount numeric(10, 2),
    platform_fees numeric(10, 2),
    monime_fees numeric(10, 2),
    net_payout numeric(10, 2),
    monime_payout_id text,
    recipient_phone text,
    monime_payout_status text,
    created_at timestamp with time zone default now(),
    updated_at timestamp with time zone
);
alter table public.payouts enable row level security;
create policy "Payouts are viewable by the organizer." on public.payouts for select using (auth.uid() = organizer_id);

-- This trigger automatically creates a profile entry when a new user signs up via Supabase Auth.
create function public.handle_new_user()
returns trigger
language plpgsql
security definer set search_path = public
as $$
begin
  insert into public.profiles (id, first_name, last_name, email)
  values (new.id, new.raw_user_meta_data->>'first_name', new.raw_user_meta_data->>'last_name', new.email);
  return new;
end;
$$;

create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();

-- RPC function for getting attendees for a specific event
CREATE OR REPLACE FUNCTION public.get_attendees_for_event(event_id_param INT)
RETURNS TABLE(
    ticket_id BIGINT,
    checked_in BOOLEAN,
    checked_out BOOLEAN,
    status public.ticket_status,
    first_name TEXT,
    last_name TEXT,
    email TEXT,
    avatar_url TEXT,
    form_responses jsonb
)
LANGUAGE plpgsql
SECURITY DEFINER SET search_path = public
AS $$
BEGIN
  IF ((SELECT organizer_id FROM public.events WHERE id = event_id_param) = auth.uid()) THEN
    RETURN QUERY
    SELECT
        t.id AS ticket_id,
        t.checked_in,
        t.checked_out,
        t.status,
        p.first_name,
        p.last_name,
        p.email,
        p.avatar_url,
        (
            SELECT jsonb_agg(
                jsonb_build_object(
                    'field_name', ff.field_name,
                    'field_value', afr.field_value
                )
            )
            FROM public.attendee_form_responses afr
            JOIN public.event_form_fields ff ON afr.form_field_id = ff.id
            WHERE afr.ticket_id = t.id
        ) as form_responses
    FROM
        public.tickets t
    JOIN
        public.profiles p ON t.user_id = p.id
    WHERE
        t.event_id = event_id_param;
  END IF;
END;
$$;


CREATE OR REPLACE FUNCTION public.get_event_attendee_counts(event_ids integer[])
 RETURNS TABLE(event_id_out integer, attendee_count bigint)
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN QUERY
    SELECT
        e.id::integer AS event_id_out,
        COUNT(t.id) AS attendee_count
    FROM
        events e
    LEFT JOIN
        tickets t ON e.id = t.event_id
    WHERE
        e.id = ANY(event_ids)
    GROUP BY
        e.id;
END;
$function$;

CREATE OR REPLACE FUNCTION public.count_users()
RETURNS integer
LANGUAGE sql
SECURITY DEFINER
AS $$
    SELECT COUNT(*)::integer FROM auth.users;
$$;
