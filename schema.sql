-- This script was generated by consolidating multiple SQL snippets.

-- 1. Create ENUM Types
CREATE TYPE public.ticket_status AS ENUM ('pending', 'approved', 'rejected', 'expired');
CREATE TYPE public.field_type AS ENUM('text', 'number', 'date', 'boolean', 'multiple-choice', 'checkboxes', 'dropdown');

-- 2. Create Profiles Table
-- This table stores public user data.
CREATE TABLE public.profiles (
    id uuid NOT NULL PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    updated_at timestamp with time zone,
    first_name text,
    last_name text,
    username text UNIQUE,
    full_name text,
    avatar_url text,
    website text,
    email text UNIQUE,
    CONSTRAINT username_length CHECK (char_length(username) >= 3)
);

ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Public profiles are viewable by everyone." ON public.profiles FOR SELECT USING (true);
CREATE POLICY "Users can insert their own profile." ON public.profiles FOR INSERT WITH CHECK (auth.uid() = id);
CREATE POLICY "Users can update their own profile." ON public.profiles FOR UPDATE USING (auth.uid() = id);

-- 3. Create Events Table
-- This table stores all event information.
CREATE TABLE public.events (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at timestamp with time zone DEFAULT now(),
    title text NOT NULL,
    description text,
    welcome_message text,
    date timestamp with time zone NOT NULL,
    end_date timestamp with time zone,
    location text,
    cover_image text,
    ticket_brand_logo text,
    ticket_brand_color text,
    organizer_id uuid REFERENCES public.profiles(id) ON DELETE SET NULL,
    capacity integer,
    is_paid boolean DEFAULT false,
    price numeric,
    is_public boolean DEFAULT true NOT NULL,
    requires_approval boolean NOT NULL DEFAULT false
);

ALTER TABLE public.events ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Public events are viewable by everyone." ON public.events FOR SELECT USING (is_public = true);
CREATE POLICY "Organizers can view their own private events." ON public.events FOR SELECT USING (auth.uid() = organizer_id);
CREATE POLICY "Organizers can insert events." ON public.events FOR INSERT WITH CHECK (auth.uid() = organizer_id);
CREATE POLICY "Organizers can update their own events." ON public.events FOR UPDATE USING (auth.uid() = organizer_id);
CREATE POLICY "Organizers can delete their own events." ON public.events FOR DELETE USING (auth.uid() = organizer_id);

-- 4. Create Event Scanners Table
-- This table links users to events they are allowed to scan.
CREATE TABLE public.event_scanners (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    event_id bigint NOT NULL REFERENCES public.events(id) ON DELETE CASCADE,
    user_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    UNIQUE(event_id, user_id)
);

ALTER TABLE public.event_scanners ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Organizers can manage scanners for their events." ON public.event_scanners FOR ALL USING (
    (SELECT organizer_id FROM public.events WHERE id = event_id) = auth.uid()
);
CREATE POLICY "Scanners can view their own assignments." ON public.event_scanners FOR SELECT USING (auth.uid() = user_id);


-- 5. Create Tickets Table
-- This table links users (attendees) to events.
CREATE TABLE public.tickets (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at timestamp with time zone DEFAULT now(),
    event_id bigint REFERENCES public.events(id) ON DELETE CASCADE,
    user_id uuid REFERENCES public.profiles(id) ON DELETE CASCADE,
    qr_token uuid UNIQUE,
    checked_in boolean DEFAULT false NOT NULL,
    checked_in_at timestamp with time zone,
    checked_out boolean DEFAULT false NOT NULL,
    checked_out_at timestamp with time zone,
    status public.ticket_status NOT NULL DEFAULT 'pending',
    UNIQUE(event_id, user_id)
);

ALTER TABLE public.tickets ENABLE ROW LEVEL SECURITY;

-- RLS Policies for Tickets Table
CREATE POLICY "Organizers, scanners or attendees can view tickets"
ON public.tickets FOR SELECT USING (
    auth.uid() = (SELECT organizer_id FROM public.events e WHERE e.id = tickets.event_id LIMIT 1)
    OR EXISTS (
        SELECT 1 FROM public.event_scanners es
        WHERE es.event_id = tickets.event_id
        AND es.user_id = auth.uid()
    )
    OR auth.uid() = user_id -- Attendee can view their own ticket
);

CREATE POLICY "Organizers or scanners can update tickets"
ON public.tickets FOR UPDATE USING (
    auth.uid() = (SELECT organizer_id FROM public.events e WHERE e.id = tickets.event_id LIMIT 1)
    OR EXISTS (
        SELECT 1 FROM public.event_scanners es
        WHERE es.event_id = tickets.event_id
        AND es.user_id = auth.uid()
    )
);

CREATE POLICY "Users can create their own tickets." ON public.tickets FOR INSERT WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Users can delete their own tickets (unregister)." ON public.tickets FOR DELETE USING (auth.uid() = user_id);

-- 6. Create Custom Form Field Tables
-- Table to store the custom questions for each event
CREATE TABLE public.event_form_fields (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  event_id bigint NOT NULL REFERENCES public.events(id) ON DELETE CASCADE,
  field_name text NOT NULL,
  field_type public.field_type NOT NULL,
  is_required boolean NOT NULL DEFAULT false,
  "order" int NOT NULL
);

ALTER TABLE public.event_form_fields ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Public can view form fields for any event." ON public.event_form_fields FOR SELECT USING (true);
CREATE POLICY "Organizers can manage form fields for their events." ON public.event_form_fields FOR ALL USING (
  (SELECT organizer_id FROM public.events WHERE id = event_id) = auth.uid()
);

-- Create table for field options
CREATE TABLE public.event_form_field_options (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    form_field_id bigint NOT NULL REFERENCES public.event_form_fields(id) ON DELETE CASCADE,
    value text NOT NULL
);

ALTER TABLE public.event_form_field_options ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Public can view form field options." ON public.event_form_field_options FOR SELECT USING (true);
CREATE POLICY "Organizers can manage options for their fields." ON public.event_form_field_options FOR ALL USING (
    (SELECT organizer_id FROM public.events WHERE id = (SELECT event_id FROM public.event_form_fields WHERE id = form_field_id)) = auth.uid()
);


-- Table to store attendee responses
CREATE TABLE public.attendee_form_responses (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  ticket_id bigint NOT NULL REFERENCES public.tickets(id) ON DELETE CASCADE,
  form_field_id bigint NOT NULL REFERENCES public.event_form_fields(id) ON DELETE CASCADE,
  field_value text NOT NULL
);

ALTER TABLE public.attendee_form_responses ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can view their own form responses." ON public.attendee_form_responses FOR SELECT USING (
    (SELECT user_id FROM public.tickets WHERE id = ticket_id) = auth.uid()
);
CREATE POLICY "Organizers can view form responses for their events." ON public.attendee_form_responses FOR SELECT USING (
    (SELECT organizer_id FROM public.events WHERE id = (SELECT event_id FROM public.tickets WHERE id = ticket_id)) = auth.uid()
);
CREATE POLICY "Users can insert their own form responses." ON public.attendee_form_responses FOR INSERT WITH CHECK (
    (SELECT user_id FROM public.tickets WHERE id = ticket_id) = auth.uid()
);

-- 7. Create Database Functions & Triggers
-- Function to populate the profiles table on new user signup
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER SET search_path = public
AS $$
BEGIN
  INSERT INTO public.profiles (id, full_name, avatar_url, first_name, last_name, email)
  VALUES (
    new.id,
    new.raw_user_meta_data->>'full_name',
    new.raw_user_meta_data->>'avatar_url',
    new.raw_user_meta_data->>'first_name',
    new.raw_user_meta_data->>'last_name',
    new.email
  );
  RETURN new;
END;
$$;

-- Trigger to call the function on new user signup
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();

-- Function to securely get event attendees for an organizer
CREATE OR REPLACE FUNCTION public.get_attendees_for_event(event_id_param INT)
RETURNS TABLE(
    ticket_id BIGINT,
    checked_in BOOLEAN,
    checked_out BOOLEAN,
    status public.ticket_status,
    first_name TEXT,
    last_name TEXT,
    email TEXT,
    avatar_url TEXT,
    form_responses JSON
)
LANGUAGE plpgsql
SECURITY DEFINER SET search_path = public
AS $$
BEGIN
  IF ((SELECT organizer_id FROM public.events WHERE id = event_id_param) = auth.uid()) THEN
    RETURN QUERY
    SELECT
        t.id AS ticket_id,
        t.checked_in,
        t.checked_out,
        t.status,
        p.first_name,
        p.last_name,
        p.email,
        p.avatar_url,
        json_agg(json_build_object(
            'field_name', f.field_name,
            'field_value', fr.field_value
        )) FILTER (WHERE fr.id IS NOT NULL) AS form_responses
    FROM
        public.tickets t
    JOIN
        public.profiles p ON t.user_id = p.id
    LEFT JOIN
        public.attendee_form_responses fr ON fr.ticket_id = t.id
    LEFT JOIN
        public.event_form_fields f ON fr.form_field_id = f.id
    WHERE
        t.event_id = event_id_param
    GROUP BY
        t.id, p.id;
  END IF;
END;
$$;

-- Function to count total registered users
CREATE OR REPLACE FUNCTION public.count_users()
RETURNS int
LANGUAGE plpgsql
AS $$
BEGIN
  RETURN (SELECT count(*) FROM auth.users);
END;
$$;

-- 8. Set up Storage Buckets and Policies
INSERT INTO storage.buckets (id, name, public)
VALUES ('avatars', 'avatars', true) ON CONFLICT (id) DO NOTHING;

INSERT INTO storage.buckets (id, name, public, file_size_limit, allowed_mime_types)
VALUES
    ('event-covers', 'event-covers', true, 5242880, ARRAY['image/jpeg', 'image/jpg', 'image/png', 'image/webp', 'image/gif']),
    ('event-images', 'event-images', true, 5242880, ARRAY['image/jpeg', 'image/jpg', 'image/png', 'image/webp', 'image/gif'])
ON CONFLICT (id) DO UPDATE SET
    public = EXCLUDED.public,
    file_size_limit = EXCLUDED.file_size_limit,
    allowed_mime_types = EXCLUDED.allowed_mime_types;

-- Avatar Policies
CREATE POLICY "Avatar images are publicly accessible." ON storage.objects FOR SELECT USING (bucket_id = 'avatars');
CREATE POLICY "Anyone can upload an avatar." ON storage.objects FOR INSERT WITH CHECK (bucket_id = 'avatars');

-- Event Image Policies
CREATE POLICY "Event images are publicly accessible"
ON storage.objects FOR SELECT
USING (bucket_id IN ('event-covers', 'event-images'));

CREATE POLICY "Authenticated users can upload event images"
ON storage.objects FOR INSERT
WITH CHECK (
    bucket_id IN ('event-covers', 'event-images')
    AND auth.role() = 'authenticated'
);

CREATE POLICY "Users can manage their own event images"
ON storage.objects FOR UPDATE
USING (
    bucket_id IN ('event-covers', 'event-images')
    AND auth.role() = 'authenticated'
);

CREATE POLICY "Users can delete their own event images"
ON storage.objects FOR DELETE
USING (
    bucket_id IN ('event-covers', 'event-images')
    AND auth.role() = 'authenticated'
);

-- Function to get attendee counts for multiple events
CREATE OR REPLACE FUNCTION public.get_event_attendee_counts(event_ids int[])
RETURNS TABLE(event_id_out int, attendee_count int)
LANGUAGE plpgsql
AS $$
BEGIN
  RETURN QUERY
  SELECT t.event_id, count(t.id)::int
  FROM public.tickets t
  WHERE t.event_id = ANY(event_ids)
  GROUP BY t.event_id;
END;
$$;

-- Function to get attendee count for a single event
CREATE OR REPLACE FUNCTION public.get_event_attendee_count(event_id_param int)
RETURNS int
LANGUAGE plpgsql
AS $$
BEGIN
  RETURN (
    SELECT count(id)::int
    FROM public.tickets
    WHERE event_id = event_id_param
  );
END;
$$;

-- 9. Create Payments Table
CREATE TABLE public.payments (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at timestamp with time zone DEFAULT now(),
    ticket_id bigint REFERENCES public.tickets(id) ON DELETE CASCADE,
    amount numeric NOT NULL,
    currency text NOT NULL,
    status text NOT NULL,
    payment_provider text,
    transaction_id text,
    UNIQUE(ticket_id)
);

ALTER TABLE public.payments ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can view their own payments." ON public.payments FOR SELECT USING (
    (SELECT user_id FROM public.tickets WHERE id = ticket_id) = auth.uid()
);
CREATE POLICY "Organizers can view payments for their events." ON public.payments FOR SELECT USING (
    (SELECT organizer_id FROM public.events WHERE id = (SELECT event_id FROM public.tickets WHERE id = ticket_id)) = auth.uid()
);
