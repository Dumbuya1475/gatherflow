-- =====================================================
-- COMPLETE EVENT MANAGEMENT DATABASE SETUP
-- =====================================================
-- Run this script on a fresh database to set up everything
-- This creates ALL tables, types, functions, and policies
-- =====================================================

-- 1. CREATE CUSTOM TYPES
-- =====================================================

CREATE TYPE public.ticket_status AS ENUM ('pending', 'approved', 'rejected');
CREATE TYPE public.field_type AS ENUM ('text', 'number', 'date', 'boolean', 'multiple-choice', 'checkboxes', 'dropdown');

-- =====================================================
-- 2. CREATE CORE TABLES
-- =====================================================

-- Create Profiles Table
CREATE TABLE public.profiles (
    id uuid NOT NULL PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    first_name text,
    last_name text,
    username text UNIQUE,
    full_name text,
    avatar_url text,
    website text,
    email text UNIQUE,
    CONSTRAINT username_length CHECK (char_length(username) >= 3)
);

-- Create Events Table (without ticket_background_image)
CREATE TABLE public.events (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at timestamp with time zone DEFAULT now(),
    title text NOT NULL,
    description text,
    welcome_message text,
    date timestamp with time zone NOT NULL,
    end_date timestamp with time zone,
    location text,
    cover_image text,
    ticket_brand_logo text,
    ticket_brand_color text,
    organizer_id uuid REFERENCES public.profiles(id) ON DELETE SET NULL,
    capacity integer,
    is_paid boolean DEFAULT false,
    price numeric,
    is_public boolean DEFAULT true NOT NULL,
    requires_approval boolean DEFAULT false NOT NULL
);

-- Create Event Scanners Table
CREATE TABLE public.event_scanners (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    event_id bigint NOT NULL REFERENCES public.events(id) ON DELETE CASCADE,
    user_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    created_at timestamp with time zone DEFAULT now(),
    UNIQUE(event_id, user_id)
);

-- Create Tickets Table
CREATE TABLE public.tickets (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at timestamp with time zone DEFAULT now(),
    event_id bigint NOT NULL REFERENCES public.events(id) ON DELETE CASCADE,
    user_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    qr_token uuid DEFAULT gen_random_uuid() NOT NULL UNIQUE,
    checked_in boolean DEFAULT false NOT NULL,
    checked_in_at timestamp with time zone,
    checked_out boolean DEFAULT false NOT NULL,
    checked_out_at timestamp with time zone,
    status public.ticket_status DEFAULT 'pending' NOT NULL,
    UNIQUE(event_id, user_id)
);

-- Create Event Form Fields Table
CREATE TABLE public.event_form_fields (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    event_id bigint NOT NULL REFERENCES public.events(id) ON DELETE CASCADE,
    field_name text NOT NULL,
    field_type public.field_type NOT NULL,
    is_required boolean DEFAULT false NOT NULL,
    "order" integer NOT NULL,
    created_at timestamp with time zone DEFAULT now()
);

-- Create Event Form Field Options Table (for choice-based fields)
CREATE TABLE public.event_form_field_options (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    form_field_id bigint NOT NULL REFERENCES public.event_form_fields(id) ON DELETE CASCADE,
    value text NOT NULL,
    created_at timestamp with time zone DEFAULT now()
);

-- Create Attendee Form Responses Table
CREATE TABLE public.attendee_form_responses (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    ticket_id bigint NOT NULL REFERENCES public.tickets(id) ON DELETE CASCADE,
    form_field_id bigint NOT NULL REFERENCES public.event_form_fields(id) ON DELETE CASCADE,
    field_value text NOT NULL,
    created_at timestamp with time zone DEFAULT now()
);

-- =====================================================
-- 3. ENABLE ROW LEVEL SECURITY
-- =====================================================

ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.events ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.event_scanners ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.tickets ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.event_form_fields ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.event_form_field_options ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.attendee_form_responses ENABLE ROW LEVEL SECURITY;

-- =====================================================
-- 4. CREATE SECURITY POLICIES
-- =====================================================

-- PROFILES POLICIES
CREATE POLICY "Public profiles are viewable by everyone" ON public.profiles 
    FOR SELECT USING (true);
CREATE POLICY "Users can insert their own profile" ON public.profiles 
    FOR INSERT WITH CHECK (auth.uid() = id);
CREATE POLICY "Users can update their own profile" ON public.profiles 
    FOR UPDATE USING (auth.uid() = id);

-- EVENTS POLICIES
CREATE POLICY "Public events are viewable by everyone" ON public.events 
    FOR SELECT USING (is_public = true);
CREATE POLICY "Organizers can view their own private events" ON public.events 
    FOR SELECT USING (auth.uid() = organizer_id);
CREATE POLICY "Organizers can insert events" ON public.events 
    FOR INSERT WITH CHECK (auth.uid() = organizer_id);
CREATE POLICY "Organizers can update their own events" ON public.events 
    FOR UPDATE USING (auth.uid() = organizer_id);
CREATE POLICY "Organizers can delete their own events" ON public.events 
    FOR DELETE USING (auth.uid() = organizer_id);

-- EVENT SCANNERS POLICIES
CREATE POLICY "Organizers can manage scanners for their events" ON public.event_scanners 
    FOR ALL USING (
        (SELECT organizer_id FROM public.events WHERE id = event_id) = auth.uid()
    );
CREATE POLICY "Scanners can view their own assignments" ON public.event_scanners 
    FOR SELECT USING (auth.uid() = user_id);

-- TICKETS POLICIES
CREATE POLICY "Organizers, scanners or attendees can view tickets" ON public.tickets
    FOR SELECT USING (
        auth.uid() = (SELECT organizer_id FROM public.events e WHERE e.id = tickets.event_id)
        OR EXISTS (
            SELECT 1 FROM public.event_scanners es
            WHERE es.event_id = tickets.event_id AND es.user_id = auth.uid()
        )
        OR auth.uid() = user_id
    );

CREATE POLICY "Users can create their own tickets" ON public.tickets 
    FOR INSERT WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Organizers or scanners can update tickets" ON public.tickets
    FOR UPDATE USING (
        auth.uid() = (SELECT organizer_id FROM public.events e WHERE e.id = tickets.event_id)
        OR EXISTS (
            SELECT 1 FROM public.event_scanners es
            WHERE es.event_id = tickets.event_id AND es.user_id = auth.uid()
        )
    );

CREATE POLICY "Users can delete their own tickets (unregister)" ON public.tickets 
    FOR DELETE USING (auth.uid() = user_id);

-- EVENT FORM FIELDS POLICIES
CREATE POLICY "Public can view form fields for any event" ON public.event_form_fields 
    FOR SELECT USING (true);
CREATE POLICY "Organizers can manage form fields for their events" ON public.event_form_fields 
    FOR ALL USING (
        (SELECT organizer_id FROM public.events WHERE id = event_id) = auth.uid()
    );

-- EVENT FORM FIELD OPTIONS POLICIES
CREATE POLICY "Public can view form field options" ON public.event_form_field_options 
    FOR SELECT USING (true);
CREATE POLICY "Organizers can manage options for their fields" ON public.event_form_field_options 
    FOR ALL USING (
        (SELECT organizer_id FROM public.events WHERE id = (
            SELECT event_id FROM public.event_form_fields WHERE id = form_field_id
        )) = auth.uid()
    );

-- ATTENDEE FORM RESPONSES POLICIES
CREATE POLICY "Users can view their own form responses" ON public.attendee_form_responses 
    FOR SELECT USING (
        (SELECT user_id FROM public.tickets WHERE id = ticket_id) = auth.uid()
    );

CREATE POLICY "Organizers can view form responses for their events" ON public.attendee_form_responses 
    FOR SELECT USING (
        (SELECT organizer_id FROM public.events WHERE id = (
            SELECT event_id FROM public.tickets WHERE id = ticket_id
        )) = auth.uid()
    );

CREATE POLICY "Users can insert their own form responses" ON public.attendee_form_responses 
    FOR INSERT WITH CHECK (
        (SELECT user_id FROM public.tickets WHERE id = ticket_id) = auth.uid()
    );

-- =====================================================
-- 5. CREATE FUNCTIONS AND TRIGGERS
-- =====================================================

-- Function to populate profiles table on new user signup
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER SET search_path = public
AS $$
BEGIN
    INSERT INTO public.profiles (
        id, 
        email,
        first_name, 
        last_name, 
        full_name, 
        avatar_url,
        created_at,
        updated_at
    )
    VALUES (
        new.id,
        new.email,
        new.raw_user_meta_data->>'first_name',
        new.raw_user_meta_data->>'last_name',
        new.raw_user_meta_data->>'full_name',
        new.raw_user_meta_data->>'avatar_url',
        now(),
        now()
    ) ON CONFLICT (id) DO UPDATE SET
        email = EXCLUDED.email,
        first_name = COALESCE(EXCLUDED.first_name, profiles.first_name),
        last_name = COALESCE(EXCLUDED.last_name, profiles.last_name),
        full_name = COALESCE(EXCLUDED.full_name, profiles.full_name),
        avatar_url = COALESCE(EXCLUDED.avatar_url, profiles.avatar_url),
        updated_at = now();
    RETURN new;
END;
$$;

-- Trigger to call the function on new user signup
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE TRIGGER on_auth_user_created
    AFTER INSERT ON auth.users
    FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();

-- Function to get attendees for an event (for organizers)
CREATE OR REPLACE FUNCTION public.get_attendees_for_event(event_id_param INT)
RETURNS TABLE(
    ticket_id BIGINT,
    checked_in BOOLEAN,
    checked_out BOOLEAN,
    status public.ticket_status,
    first_name TEXT,
    last_name TEXT,
    email TEXT,
    avatar_url TEXT,
    form_responses JSON
)
LANGUAGE plpgsql
SECURITY DEFINER SET search_path = public
AS $$
BEGIN
    IF ((SELECT organizer_id FROM public.events WHERE id = event_id_param) = auth.uid()) THEN
        RETURN QUERY
        SELECT
            t.id AS ticket_id,
            t.checked_in,
            t.checked_out,
            t.status,
            p.first_name,
            p.last_name,
            p.email,
            p.avatar_url,
            json_agg(json_build_object(
                'field_name', f.field_name,
                'field_value', fr.field_value
            )) FILTER (WHERE fr.id IS NOT NULL) AS form_responses
        FROM
            public.tickets t
        JOIN
            public.profiles p ON t.user_id = p.id
        LEFT JOIN
            public.attendee_form_responses fr ON fr.ticket_id = t.id
        LEFT JOIN
            public.event_form_fields f ON fr.form_field_id = f.id
        WHERE
            t.event_id = event_id_param
        GROUP BY
            t.id, p.id;
    END IF;
END;
$$;

-- Function to get attendee count for a single event
CREATE OR REPLACE FUNCTION public.get_event_attendee_count(event_id_param int)
RETURNS int
LANGUAGE plpgsql
AS $$
BEGIN
    RETURN (
        SELECT count(id)::int
        FROM public.tickets
        WHERE event_id = event_id_param
        AND status IN ('approved', 'pending')
    );
END;
$$;

-- Function to get attendee counts for multiple events
CREATE OR REPLACE FUNCTION public.get_event_attendee_counts(event_ids int[])
RETURNS TABLE(event_id_out int, attendee_count int)
LANGUAGE plpgsql
AS $$
BEGIN
    RETURN QUERY
    SELECT 
        t.event_id, 
        count(t.id)::int
    FROM public.tickets t
    WHERE t.event_id = ANY(event_ids)
    AND t.status IN ('approved', 'pending')
    GROUP BY t.event_id;
END;
$$;

-- Function to count total registered users
CREATE OR REPLACE FUNCTION public.count_users()
RETURNS int
LANGUAGE plpgsql
AS $$
BEGIN
    RETURN (SELECT count(*) FROM auth.users);
END;
$$;

-- =====================================================
-- 6. CREATE STORAGE BUCKETS
-- =====================================================

-- Create storage buckets
INSERT INTO storage.buckets (id, name, public)
VALUES ('avatars', 'avatars', true) 
ON CONFLICT (id) DO NOTHING;

INSERT INTO storage.buckets (id, name, public, file_size_limit, allowed_mime_types)
VALUES
    ('event-covers', 'event-covers', true, 5242880, ARRAY['image/jpeg', 'image/jpg', 'image/png', 'image/webp', 'image/gif']),
    ('event-images', 'event-images', true, 5242880, ARRAY['image/jpeg', 'image/jpg', 'image/png', 'image/webp', 'image/gif']),
    ('event-logos', 'event-logos', true, 5242880, ARRAY['image/jpeg', 'image/jpg', 'image/png', 'image/webp', 'image/gif'])
ON CONFLICT (id) DO UPDATE SET
    public = EXCLUDED.public,
    file_size_limit = EXCLUDED.file_size_limit,
    allowed_mime_types = EXCLUDED.allowed_mime_types;

-- =====================================================
-- 7. CREATE STORAGE POLICIES
-- =====================================================

-- Avatar storage policies
CREATE POLICY "Avatar images are publicly accessible" ON storage.objects
    FOR SELECT USING (bucket_id = 'avatars');

CREATE POLICY "Anyone can upload an avatar" ON storage.objects
    FOR INSERT WITH CHECK (bucket_id = 'avatars');

CREATE POLICY "Users can update their own avatar" ON storage.objects
    FOR UPDATE USING (bucket_id = 'avatars' AND auth.role() = 'authenticated');

CREATE POLICY "Users can delete their own avatar" ON storage.objects
    FOR DELETE USING (bucket_id = 'avatars' AND auth.role() = 'authenticated');

-- Event images storage policies
CREATE POLICY "Event images are publicly accessible" ON storage.objects
    FOR SELECT USING (bucket_id IN ('event-covers', 'event-images', 'event-logos'));

CREATE POLICY "Authenticated users can upload event images" ON storage.objects
    FOR INSERT WITH CHECK (
        bucket_id IN ('event-covers', 'event-images', 'event-logos') 
        AND auth.role() = 'authenticated'
    );

CREATE POLICY "Users can manage event images" ON storage.objects
    FOR UPDATE USING (
        bucket_id IN ('event-covers', 'event-images', 'event-logos') 
        AND auth.role() = 'authenticated'
    );

CREATE POLICY "Users can delete event images" ON storage.objects
    FOR DELETE USING (
        bucket_id IN ('event-covers', 'event-images', 'event-logos') 
        AND auth.role() = 'authenticated'
    );

-- =====================================================
-- 8. CREATE PERFORMANCE INDEXES
-- =====================================================

CREATE INDEX idx_events_organizer_id ON public.events(organizer_id);
CREATE INDEX idx_events_date ON public.events(date);
CREATE INDEX idx_events_is_public ON public.events(is_public);
CREATE INDEX idx_tickets_event_id ON public.tickets(event_id);
CREATE INDEX idx_tickets_user_id ON public.tickets(user_id);
CREATE INDEX idx_tickets_qr_token ON public.tickets(qr_token);
CREATE INDEX idx_tickets_status ON public.tickets(status);
CREATE INDEX idx_event_scanners_event_user ON public.event_scanners(event_id, user_id);
CREATE INDEX idx_form_fields_event_id ON public.event_form_fields(event_id);
CREATE INDEX idx_form_responses_ticket_id ON public.attendee_form_responses(ticket_id);

-- =====================================================
-- SETUP COMPLETE
-- =====================================================
-- Your complete event management database is now ready!
-- 
-- Features included:
-- ✅ User authentication and profiles
-- ✅ Event creation and management
-- ✅ Public/private events with capacity limits
-- ✅ Paid/free events with pricing
-- ✅ Event branding (covers, logos, colors)
-- ✅ Ticket system with QR codes
-- ✅ Approval workflow (pending/approved/rejected)
-- ✅ Check-in/check-out tracking
-- ✅ Event scanners (designated check-in users)
-- ✅ Custom registration forms with multiple field types
-- ✅ File storage for images
-- ✅ Comprehensive security policies
-- ✅ Performance optimizations
-- =====================================================



-- ================================================================
-- Fix QR Token Workflow
-- Run this to update your existing database schema

-- 1. Make qr_token nullable (since pending tickets won't have one)
ALTER TABLE public.tickets 
ALTER COLUMN qr_token DROP NOT NULL;

-- 2. Remove the default QR token generation
ALTER TABLE public.tickets 
ALTER COLUMN qr_token DROP DEFAULT;

-- 3. Update existing tickets to remove QR tokens for pending/rejected tickets
UPDATE public.tickets 
SET qr_token = NULL 
WHERE status IN ('pending', 'rejected');

-- 4. Create a function to generate QR token when ticket is approved
CREATE OR REPLACE FUNCTION public.generate_qr_token_on_approval()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER SET search_path = public
AS $$
BEGIN
    -- If status is changing to 'approved' and there's no QR token yet
    IF NEW.status = 'approved' AND OLD.status != 'approved' AND NEW.qr_token IS NULL THEN
        NEW.qr_token = gen_random_uuid();
    END IF;
    
    -- If status is changing to 'rejected', remove QR token
    IF NEW.status = 'rejected' AND OLD.status != 'rejected' THEN
        NEW.qr_token = NULL;
    END IF;
    
    RETURN NEW;
END;
$$;

-- 5. Create trigger to automatically handle QR token generation
DROP TRIGGER IF EXISTS ticket_qr_token_trigger ON public.tickets;
CREATE TRIGGER ticket_qr_token_trigger
    BEFORE UPDATE ON public.tickets
    FOR EACH ROW
    EXECUTE PROCEDURE public.generate_qr_token_on_approval();

-- 6. Update the tickets table index to handle nullable QR tokens
DROP INDEX IF EXISTS idx_tickets_qr_token;
CREATE INDEX idx_tickets_qr_token ON public.tickets(qr_token) WHERE qr_token IS NOT NULL;


-- ===========================================


-- This SQL script updates the 'profiles' table to allow for guest users
-- who are not registered in the 'auth.users' table.

-- Step 1: Add the 'is_guest' column to the 'profiles' table.
-- This column will be used to identify guest profiles.
ALTER TABLE public.profiles
ADD COLUMN is_guest BOOLEAN DEFAULT FALSE;

-- Step 2: Remove the foreign key constraint on the 'id' column.
-- This is necessary to allow profiles to exist without a corresponding user in 'auth.users'.
-- Note: The constraint name 'profiles_id_fkey' is a common default, but it might be different in your database.
-- If this command fails, you will need to find the correct constraint name.
ALTER TABLE public.profiles
DROP CONSTRAINT profiles_id_fkey;

-- Step 3: Ensure the 'id' column is a primary key and generates a UUID for new profiles.
-- This is for guest profiles, as registered users will get their id from auth.users.
ALTER TABLE public.profiles
ALTER COLUMN id SET DEFAULT gen_random_uuid();

-- ================================================

-- This SQL script updates the 'profiles' table to allow for guest users
-- who are not registered in the 'auth.users' table.

-- Step 1: Add the 'is_guest' column to the 'profiles' table.
-- This column will be used to identify guest profiles.
ALTER TABLE public.profiles
ADD COLUMN is_guest BOOLEAN DEFAULT FALSE;

-- Step 2: Remove the foreign key constraint on the 'id' column.
-- This is necessary to allow profiles to exist without a corresponding user in 'auth.users'.
-- Note: The constraint name 'profiles_id_fkey' is a common default, but it might be different in your database.
-- If this command fails, you will need to find the correct constraint name.
ALTER TABLE public.profiles
DROP CONSTRAINT profiles_id_fkey;

-- Step 3: Ensure the 'id' column is a primary key and generates a UUID for new profiles.
-- This is for guest profiles, as registered users will get their id from auth.users.
ALTER TABLE public.profiles
ALTER COLUMN id SET DEFAULT gen_random_uuid();


-- ==================================================

-- This SQL script updates the 'profiles' table to allow for guest users
-- who are not registered in the 'auth.users' table.

-- Step 1: Add the 'is_guest' column to the 'profiles' table.
-- This column will be used to identify guest profiles.
ALTER TABLE public.profiles
ADD COLUMN is_guest BOOLEAN DEFAULT FALSE;

-- Step 2: Remove the foreign key constraint on the 'id' column.
-- This is necessary to allow profiles to exist without a corresponding user in 'auth.users'.
-- Note: The constraint name 'profiles_id_fkey' is a common default, but it might be different in your database.
ALTER TABLE public.profiles
DROP CONSTRAINT profiles_id_fkey;

-- Step 3: Ensure the 'id' column is a primary key and generates a UUID for new profiles.
-- This is for guest profiles, as registered users will get their id from auth.users.
ALTER TABLE public.profiles
ALTER COLUMN id SET DEFAULT gen_random_uuid();













-- =====================================

ALTER TYPE public.ticket_status ADD VALUE 'expired';


-- ================================

-- Add 'expired' to the ticket_status ENUM
ALTER TYPE public.ticket_status ADD VALUE 'expired';

-- Create Payments Table
CREATE TABLE public.payments (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at timestamp with time zone DEFAULT now(),
    ticket_id bigint REFERENCES public.tickets(id) ON DELETE CASCADE,
    amount numeric NOT NULL,
    currency text NOT NULL,
    status text NOT NULL,
    payment_provider text,
    transaction_id text,
    UNIQUE(ticket_id)
);

ALTER TABLE public.payments ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can view their own payments." ON public.payments FOR SELECT USING (
    (SELECT user_id FROM public.tickets WHERE id = ticket_id) = auth.uid()
);
CREATE POLICY "Organizers can view payments for their events." ON public.payments FOR SELECT USING (
    (SELECT organizer_id FROM public.events WHERE id = (SELECT event_id FROM public.tickets WHERE id = ticket_id)) = auth.uid()
);

